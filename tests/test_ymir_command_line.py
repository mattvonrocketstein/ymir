# -*- coding: utf-8 -*-
import os
import inspect
import contextlib
import pytest

import mock
from fabric import api
from peak.util.imports import lazyModule

from ymir.util import TemporaryDirectory
from ymir import commands
import addict
from ymir import validation

import tests.common as test_common

yservice = lazyModule('ymir.service')


def test_ymir_init():
    """ ymir init should work, and should copy all files from ymir.skeleton """
    with test_common.demo_service() as ctx:
        service_json = os.path.join(ctx.service_dir, 'service.json')
        err = '`ymir init {0}` did not copy file {0} from skeleton!'
        skeleton_files_and_dirs = []
        for root, dirs, files in os.walk(test_common.skeleton_dir):
            for name in files:
                fullpath = os.path.join(root, name)
                skeleton_files_and_dirs.append(
                    fullpath.replace(test_common.skeleton_dir + '/', ''))
            for name in dirs:
                fullpath = os.path.join(root, name)
                skeleton_files_and_dirs.append(
                    fullpath.replace(test_common.skeleton_dir + '/', ''))
        skeleton_files_and_dirs = [
            fname for fname in skeleton_files_and_dirs if
            not os.path.splitext(fname)[-1] == '.pyc'
        ]
        for fname in skeleton_files_and_dirs:
            file_copied_from_skeleton = os.path.join(ctx.service_dir, fname)
            this_err = err.format(file_copied_from_skeleton)
            assert os.path.exists(file_copied_from_skeleton), this_err


def test_ymir_help():
    """ `ymir help` should work and should return correct status """
    with api.quiet():
        err = '`ymir -h` should always be a valid command line invocation'
        assert not api.local('ymir -h').failed, err
        err = '`ymir --help` should always be a valid command line invocation'
        assert not api.local('ymir --help').failed, err
        err = '`ymir help` should always be a valid command line invocation'
        assert not api.local('ymir help').failed, err


def test_ymir_invalid_arg():
    """ ymir invocation with bad argument should fail """
    with api.quiet():
        err = 'ymir invocation with a bad argument should fail'
        assert api.local('ymir bad_arg').failed, err


def test_ymir_sg():
    """ """
    with api.quiet():
        err = '`{0}` should always require an argument or ./security_groups.json'
        assert api.local('ymir sg').failed, err.format('ymir sg')
        assert api.local('ymir security_group').failed, err.format(
            'ymir security_group')
        err = 'skeleton directory must contain security_groups.json'
        assert os.path.exists(
            os.path.join(test_common.skeleton_dir, 'security_groups.json')), err
        with api.lcd(test_common.skeleton_dir):
            err = 'default skeleton security group should fail as it has no ssh rule'
            assert api.local('ymir sg ./security_groups.json').failed, err


def test_ymir_validate():
    """ """
    with api.settings(warn_only=True):
        with api.lcd(test_common.skeleton_dir):
            err = 'ymir validate should fail without AWS_PROFILE envvar set'
            assert api.local('ymir validate').failed, err


def test_ymir_init_with_preexisting_directory():
    """ running `ymir init foo` twice should fail the second time """
    with TemporaryDirectory() as tmpdir:
        with contextlib.nested(api.lcd(tmpdir), api.quiet()):
            err = 'first attempt to init project should have succeeded!'
            assert not api.local('ymir init foo').failed, err
            err = 'second attempt to init project should have failed!'
            assert api.local('ymir init foo').failed, err


@test_common.mock_aws
@mock.patch('ymir.validation.validate')
def test_skeleton_service_validation(mock_validate):
    """ the service generated by `ymir init` should NOT validate """
    with test_common.demo_service() as ctx:
        err = "test service should not validate!"
        commands.ymir_validate(
            addict.Dict(service_json=ctx.service_json))
        mock_validate.assert_called_with(ctx.service_json, simple=False)
    with test_common.demo_service() as ctx:
        with pytest.raises(SystemExit):
            commands.ymir_validate(
                addict.Dict(service_json=None))


@test_common.mock_aws
def test_sg_command():  # mock_validate):
    # by default the `ymir sg` command should NOT work with skeleton,
    # because there is no SSH rule defined
    with test_common.demo_service() as ctx:
        with pytest.raises(SystemExit):
            commands.ymir_sg(addict.Dict(sg_json=ctx.sg_json,))
        sg_json = ctx.get_sg_json()[0]
        sg_json['rules'].append(['tcp', 22, 22, '0.0.0.0/22'])
        ctx.rewrite_sg_json([sg_json])
        commands.ymir_sg(addict.Dict(sg_json=ctx.sg_json,))
