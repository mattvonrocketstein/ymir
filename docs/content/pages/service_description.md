Title: Service Descriptions
Category: Python
Slug: service-description
sortorder: 4
Authors: mvr
Summary: Service Descriptions

[TOC]

Service descriptions are JSON files conforming to a particular schema.  Ymir parses a superset of strict JSON for the purpose of allowing trailing commas, multiple string indicators ("'" and '"'), and including "//"-prefixed comments in the files.

Should you need to export ymir configs to strict JSON for any reason, the jsonlint tool can help. Issue a command like this:

    $ jsonlint -FS $YMIR_SERVICE_JSON

In the boilerplate generated by `ymir init`, there are two different service description files; [one is for ec2](https://github.com/mattvonrocketstein/ymir/blob/master/ymir/skeleton/service.json) and [the other is for vagrant](https://github.com/mattvonrocketstein/ymir/blob/master/ymir/skeleton/vagrant.json).  You can always view the most recent service-description schema/boilerplate at the previous two links to find complete and well-commented examples.

These two files have different schemas, and the schema used by your service description determines the service object that will be instantiated, and the operations that will be available on that service object.

#### Choosing a file

By default, ymir assumes your service description is in the `service.json` file.  **If you have no need of EC2 and only want to work with vagrant**

    $ ymir init myservice
    $ cd myservice
    $ mv vagrant.json service.json

**If you want to use a file of a specific name**, you can set the environment variable `YMIR_SERVICE_JSON=...` before running [service operations](service-operations.html) commands.  Use `export var=val` in bash or execute it per command, like this:

    $ YMIR_SERVICE_JSON=my_service.json fab create

#### <a href="#templating" name="templating">Templating</a>

Service description files support reflective templating, or to put it another way, values inside your JSON may be used to render [ref]Under the hood, this works with [jinja2](http://jinja.pocoo.org/docs/dev/)[/ref] other values inside your template.

Always use double-mustaches to indicate template variables.  For example, in the JSON below, the value of "name" would be rendered to "OrgName-AppName-ServiceName-EnvName".

    { "org_name": "OrgName",
      "app_name": "AppName",
      "env_name": "EnvName",
      "service_name": "ServiceName",
      "name": "{{org_name}}-{{app_name}}-{{service_name}}-{{env_name}}",
    }

**Lazy variables**

Some variables are special, because they are determined just in time.  The main example is `{{host}}`, because AWS must be consulted in order to determine the external IP address of the service from it's name.

For vagrant-based services, there are several lazy variables which are determined just in time to avoid changing JSON everytime the Vagrantfile or vagrant machines change.  These variables include `{{pem}}`, `{{username}}`, and `{{port}}`.

#### EC2 JSON

<script src="https://gist-it.appspot.com/github/mattvonrocketstein/ymir/blob/vagrant/ymir/skeleton/service.json"></script>

#### Vagrant JSON

The `vagrant.json` schema is much simpler than EC2, because most of the instance particulars will be configured inside the `Vagrantfile`.

<script src="https://gist-it.appspot.com/github/mattvonrocketstein/ymir/blob/vagrant/ymir/skeleton/vagrant.json"></script>

#### Health Checks



#### Setup & provision

Both the *setup_list* and *provision_list* fields describe a list of instructions (such as puppet files which will be invoked in standalone-mode on the remote host).  Each field is a list of strings, where order matters.  Each string is an instruction, and each instruction has the form **protocol://argument_string**.

These are the available protocols:
<table>
<tr><th>Protocol</th><th>Description</th><th>Notes</th></tr>
<tr>
  <td>local://...</td>
  <td>A command to run on the local host </td>
  <td>This will execute as the local user, where the working directory is $service_root</td>
</tr>
<tr>
  <td>remote://... </td>
  <td>This instruction format specifies a command to run on the remote service
  </td>
  <td>This will execute as {{username}}, which normally means sudo is allowed.  <br/> Assumptions should not be made about the working directory.
  </td>
</tr>
<tr>
  <td>puppet://...</td>
  <td>This instruction specifies a filepath to a puppet file which will be  --apply'd on the remote host.
  </td>
  <td>The path is relative to $service_root (usually looks like `puppet://puppet/site.pp`)</td>
</tr>
<tr>
  <td>ansible-role://...</td>
  <td>This instruction is given the name of a single ansible role which will be applied to the remote host, from the localhost.
  </td>
  <td>Convenient whenever the role doesn't need an explicit playbook.[ref] Actually the `ansible-role://` instruction does require creating a temporary file to hold the implied playbook, but users don't have to worry about it.[/ref]  The role will be downloaded with ansible-galaxy if it does not exist already.  Values usually look something like `ansible-role://user.rolename`)</td>
</tr>
<tr>
  <td>ansible-playbook://...</td>
  <td>Path to an ansible playbook to apply.</td>
  <td>Path is relative to $service_root.  Values usually look something like `ansible-playbook://ansible/play.yml`|</td>
</tr>
<tr>
  <td>ansible://...</td>
  <td>Adhoc ansible, usually with modules.</td>
  <td>The port, pem file, modulepath ($service_root/ansible), etc is already implied.  For example, to install a system package with apt the instruction would look like `ansible://--become --module-name apt -a "name=pkg_name state=present"`
  </td>
</tr>
<tr>
  <td>apt://...</td>
  <td>This instruction format installs system packages with apt, given a comma-separated list of package names
  </td>
  <td>The instruction `apt://foo,bar,baz` is a shortcut for multiple instructions like `ansible://--become --module-name apt -a "name=pkg_name state=present"`
  </td>
</tr>
<tr>
  <td>yum://...</td>
  <td>This instruction format installs system packages with yum, given a comma-separated list of package names
  </td>
  <td>The instruction `yum://foo,bar,baz` is a shortcut for multiple instructions like `ansible://--become --module-name yum -a "name=pkg_name state=present"`
  </td>
</tr>
<tr>
  <td>fabric://command_name</td>
  <td>This instruction format invokes the `command_name` command from the fabric file inside your service root.
  </td>
  <td>Commands must be simple: option-passing and specifying multiple fabric tasks is not supported.  (If you need this, use the `local://` instruction instead)
  </td>
</tr>
</table>

For more information on the difference between setup and provisioning, please see [this section](service-operations.html#setup-operation) of the service operations documentation.
